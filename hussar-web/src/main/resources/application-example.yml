##################################################################################
############################## 项目启动信息配置 开始  ##############################
##################################################################################
#server:
#  servlet:
#    context-path: /
#  port: 8280
#  tomcat:
#    port-header: HEAD,DELETE,OPTIONS,TRACE,COPY,SEARCH,PROPFIND,BOGUS       #禁止这些请求头
#    min-spare-threads: 20
#    max-threads: 500
#    max-connections: 10000
#    max-http-form-post-size: -1  #解决springboot2.X发送post请求数量限制问题
#    uri-encoding: UTF-8
#  compression:
#    enabled: true
#    mime-types: application/javascript,text/css,application/json,application/xml,text/html,text/xml,text/plain

#   使用内嵌TongWeb 需排除内嵌Tomat依赖，添加内嵌TongWeb依赖，具体参考文档《TongWeb嵌入式版本用户手册》、《轻骑兵Base平台使用嵌入式TongWeb》
#   TongWeb嵌入式服务器相关配置
#  tongweb:
#    uri-encoding: UTF-8     # 设定 URI 的解码字符集,默认UTF-8
#    #basedir:                # 设置 tongweb 的 base 目录,默认临时目录,可不配置
#    max-threads: 200        # 设置 tongweb 的最大工作线程数,默认200
#    max-connections: 10000  # 设置最大连接数 ,默认10000
#    accept-count: 100       # 最大等待队列大小,默认100
#    max-http-post-size: 2MB # 设置最大连接数, 单位为 KB,MB。默认值2MB。如果不加单位默认采用 Byte 作为单位，例：server.tongweb.max-httppost-size=1，表示 1 字节,不配置该参数表示不限
#    min-spare-threads: 10   # 最小工作线程, 默认10
#    io-mode: NIO            # IO模式,值为NIO、NIO2，默认NIO
#    not-allow-http-methods: HEAD,DELETE,OPTIONS,TRACE,COPY,SEARCH,PROPFIND,BOGUS # 禁用不安全的 Http Method，默认无，多个 method 使用逗号分隔，如 TRACE,PUT
#    relaxed-path-chars: "{,|,}"  #URL路径上允许的特殊字符,无。需要使用的特殊字符，多个使用逗号分隔多个使用逗号分隔， 如{,|,}
#    relaxed-query-chars: "{,|,}" #查询参数允许的特殊字符,无。需要使用的特殊字符，多个使用逗号分隔多个使用逗号分隔， 如{,|,}
#    license:
#      type: file                                 # 配置认证方式
#      path: classpath:/_srv/tongweb_license.dat  #配置 license.dat 文件路径地址
##################################################################################
############################## 项目启动信息配置 结束  ##############################
##################################################################################


##############################################################################
############################## hussar配置 开始  ##############################
##############################################################################
#hussar:
############################### 组件配置 开始  ##############################
#  core:
#    encrypt:
#      type: SM4 # 存储加密的加密方式 不区分大小写 默认提供国密4算法！！！！！！！！ 修改该配置，需要重置数据库中密码所有密码！！！！！
#      enable-pw-encryption: false  #密码传输是否加密
#      pw-encryption-type: SM2 # 登录密码传输加密算法，默认提供国密SM2算法
#  cache:
#    cacheType: ehcache  # redis 是redis缓存  ehcache 是 ehcache 如果 不配置此属性默认的是ehcache
#    redisCluster: 0   #redis 模式 0 单机  1 集群 2 哨兵 默认不配置此type=0，使用的单机模式
#  audit:
#    enable: true        #是否开启审计日志
#    version: 8.2.1      #版本号，会存到审计日志的表中
#    server-name: hussar-web #服务名称，会存到审计日志的表中
#    exclude-common-columns: del_flag,create_time,creator    #排除的公共字段列，数据库字段名，多个用逗号隔开,不区分大小写
#    exclude-tables:   #排除的表名，当只设置tableName时，表示不记录这张表，当设置了columns后，表示记录这张表，只排除其中几列，表名、列名不区分大小写,如exclude-common-columns 的字段根据map-underscore-to-camel-case 配置是否变为驼峰 （true或者没有该配置）
#      - tableName: aaa
#      - tableName: ddd
#        columns:
#          - eee
#          - fff
#    exclude-url-list:   #排除的url，支持**匹配，配置了@AuditLog注解的方法可以通过此配置项排除审计日志记录
#      - /aaa/bbb
#      - /ccc/**
#  security:
#    enable: true   #是否开启认证，提供登录、登出方法，通过登录可获取token，在访问期间请求携带此token，即可进行正常访问
#    enable-authority: true  #是否开启鉴权，支持通过权限注解判断用户有没有访问权限，及二次认证功能
#    check-safe:
#      time-out: 120 #二次验证成功后距离下一次二次验证的时间
#      enable: true # 二次认证开关
#    enable-aop-authority: false  #是否开启service鉴权
#    displacement: end #单个账户超出最大登录数时处理逻辑，start踢出最先登录的人，end当前登录人无法登录
#    token-name: hussar-token    #token名称 (同时也是cookie名称)
#    timeout: -1                 #token有效期, -1代表永不过期,oauth2认证必须是-1(单位：秒)
#    activity-timeout: -1        #token临时有效期，oauth2认证必须是-1（单位：秒）
#    token-style: uuid           # token风格
#    is-log: true                # 是否输出操作日志
#    ignore-urls:   #认证白名单
#    - /global/sessionError
#    - /global/error
#    - /exception/repeat
#    - /speed/resources/file
#    - /unifiedtodo/saveTask
#    - /unifiedtodo/updateTask
#    - /unifiedtodo/deleteTask
#    - /unifiedtodo/updateTaskStatus
#    - /unifiedtodo/updateUserStatus
#    - /unifiedtodo/updateTaskUser
#    - /unifiedtodo/addTaskUser
#    - /unifiedtodo/deleteTaskUser
#    oauth2:
#      is-code: false #登录认证时是否使用授权码模式
#      is-implicit: false #登录认证时是否使用隐藏式
#      is-password: true #登录认证时是否使用密码模式
#      is-client: false #登录认证时是否使用凭证式
#      is-new-refresh: true   # 刷新token时是否更换新的refreshToken
#      header-token-key: Authorization  #token存放在header中的key值
#  job:
#    enable-server: true     #是否为调度服务,设置为true时代表自身就是调度服务，false时需要在execution中指定调度服务的地址
#    enable-single-model: true  # 是否为单体模式（单服务中既包括调度器，又包含执行器模块,且调度器仅为本服务中执行器分配任务，此时可配置为true，不再使用akka进行调度器、执行器间的通信，直接使用接口调用,akka-port、http-port无需再配置）
#    execution:
#      akka-port: 27777      #execution的akka端口，若不配置，会根据服务端口号生成一个值
#      app-name: hussar-job  #应用名称，服务对应的应用名称,单体模式下如果app-name不存在，在启动时会自动创建
#      server-address: 127.0.0.1:9006    #调度服务地址，单体设置为自身的ip+端口号，不配置时不开启调度
#    dispatch:
#      package-type: war     #解决 springboot 中无法区分jar启动还是war启动，解决websocket重复注入的问题
#      akka-port: 10086      #调度服务akka端口号，若不配置，会根据服务端口号生成一个值
#      http-port: 10010      #调度服务http端口号，若不配置，会根据服务端口号生成一个值
#      instance-cache-size: 1024 #同一个任务最大的任务实例缓存数
#      local-container-retention: 1  #释放本地磁盘空间时，保留几天内的文件(单位：天),0不保留,小于0全保留
#      remote-container-retention: -1  #释放调度服务磁盘空间时，保留几天内的文件(单位：天),0不保留,小于0全保留
#      instance-log-retention: 1     #释放磁盘空间时，保留几天内的任务实例日志(单位：天),0不保留,小于0全保留
#  oss:
#    oss-type: file                          # 文件上传存储方式：file：以本地文件形式存储、minio：上传至minio服务,默认为file
#    minio:                                  # 当存储方式选择minio时需配置以下属性
#      date-split: true                      # 是否按日期划分文件夹
#      append-bid: true                      # 存储到桶里的对象文件夹是否拼接业务ID
#      upload-path: /test/path               # 系统上传文件夹
#      url: url                              # 文件存储服务的URL
#      access-key: accessKey                 # minio accessKey
#      secret-key: secretKey                 # minio secretKey
#      bucket-name: singlebucket             # 存储桶名称
#    upload-file-type-check: true            # 是否进行上传文件类型校验
#    support-file-types: txt,doc,xls,docx,pptx,xlsx,pdf,rar,zip,png,jpg # 支持上传的文件类型
#    file:
#      date-split: true                      #是否按日期划分文件夹，即在上传路径上添加日期
#      upload-path-windows: D:\hussar        #windows环境上传路径
#      #upload-path-linux: /usr/local/hussar #linux环境上传路径
#      #upload-path-mac: /tmp/hussar         #mac环境上传路径
#  dynamic:
#    setting:
#      datasource-key-by-header: hussar-token #配置从header中那个属性获取数据源key
#  secure:
#    encrypt:
#      enabled: true                             #是否开启传输加密
#      enabled-encrypt-sign: true                #是否开启签名
#      header-encrypt: encrypt-header            #加密请求header，不存在header或header值为0时不加解密，值为1时加解密
#      enable-encrypt-cbc-mode: true             #数据传输加密中SM4算法是否使用cbc模式
#    anti-replay:
#      enabled: true                             #是否开启防重放
#      request-valid-time: 10000                 #请求有效时长 默认10S,单位毫秒
#      ignore-urls:                              #防重放白名单
#        - /themeConfig/getThemeConfigCss.css
#        - /themeConfig/getThemeColor
#        - /themeConfig/getCurrentApplicationTheme
#        - /speed/**
#        - /speedcode/**
#        - /formdesign/**
#        - /configure/center/**
#        - /flowAuth/**
#    risk-protect:
#      enable: true # 是否开启风险防护
#      actuator-access-check: true # 是否开启Actuator端点访问检查
#      actuator-access-ips: #可访问Actuator端点的ip，默认通过localhost方式请求可访问
#        - 127.0.0.1
#  mp:
#    sensitive:
#      enable: true    #是否开启数据脱敏
#    encrypt:
#      enable: true #是否开启敏感数据入库存储加密
#      encryptKey: 73022891f0f1f12fc7152290091073b1 #使用sm4 加密算法，配置sm4key,不配置有默认值。
#  log:
#    enable: false                            #是否开启日志收集、上报功能，开启日志需要配置es
#    max-send-size: 1000                      #单次拉取日志条数
#    interval: 1000                           #拉取日志时间间隔(毫秒)
#    url: http://localhost:8081/console.html#/unifiedLog           #日志页面地址，用于告警时查看错误信息
#    log-keep-days: 7                         #日志保留天数，默认保留7天，配置0永久保留
#    trace-keep-days: 7                       #链路保留天数，默认保留7天，配置0永久保留
#    es:
#      hosts: localhost:9200                  #es连接地址
#      shards: 5                              #索引分片个数
#      replicas: 1                            #索引副本个数
#      refresh-interval: 60s                  #刷新周期,需要带单位,如:60s
#      index-model: day                       #索引模型,控制创建索引的粒度,支持按天(day)或者按小时(hour)
#      index-zone-id: GMT+8                   #索引时区，默认GMT+8
#      maxResult: 100000                      #最大返回结果
#      userName: elastic                      #用户名
#      password: elastic                      #密码
#      trust-self-signed: true                #信任自签证书
#      hostname-verification: false           #hostname验证
#  ############################## 组件配置 结束  ##############################
#
#  ############################## base配置 开始  ##############################
#  refer-whitelist: # 使用前后分离，需要配置前端请求的白名单，防止跨域请求后台，例如前台请求地址为：http://192.168.6.14:8081/ 此处就配置为http://192.168.6.14:8081/
#    - http://
#    - https://
#  mobile:
#    integration:
#      ding-talk-token-url: https://oapi.dingtalk.com/gettoken          # 集成钉钉,获取token url
#      ding-talk-userid-url: https://oapi.dingtalk.com/user/getuserinfo # 集成钉钉，获取 userid url
#
#  ############################## 以下配置为系统默认配置  可根据实际项目情况自行修改##############################
#  cors:
#    allow-credentials: true                 # 置是否允许发送Cookie，用于 凭证请求
#    allowed-headers:                        # 允许所有的请求header访问，可以自定义设置任意请求头信息
#      - '*'
#    allowed-methods:                        # 允许跨域访问资源服务器的请求方式，如：POST、GET、PUT、DELETE等，“*”表示无限制
#      - '*'
#    allowed-origins:                        # 允许所有的请求域名访问跨域资源，当设置具体URL时只有被设置的url可以跨域访问
#      - '*'
#    enabled: false                           # 是否开启跨域拦截
#  firewall-xss-level: B                     # XSS过滤级别，共ABC三级，过滤严格程度依次增强，建议默认开启B级
#  xss-whitelist:                                #XSS过滤白名单
#    - /notice/update
#    - /notice/add
#
#  base:
#    domain: HUSSAR_V8
#    kaptcha-expire: 3                    #验证码失效时间  单位 minute
#
#  ############################## 以下配置为数据迁移相关的后台配置项  可根据实际项目情况自行修改##############################
#  migration:
#    # 导出数据完整性校验算法，默认不配置则不生成校验码
#    checksum: sha256
#    # 是否要求导入包内必须包含数据一致性校验码
#    require-checksum: false
#    # 导出数据签名算法，默认不配置则不签名
#    signature: rsa
#    # 导出数据签名私钥，支持 classpath:<path> 或 file:<path> 形式加载外部资源
#    signature-private-key: '<PKCS#8 格式的 RSA 私钥>'
#    # 是否要求导入包内必须包含数字签名
#    require-signature: false
#    # 导入数据签名验证公钥列表，支持 classpath:<path> 或 file:<path> 形式加载外部资源
#    signature-public-keys:
#      rsa:
#        - '<PKCS#8 格式的 RSA 公钥>'
#    # 导出数据加密算法，默认不配置则不加密
#    encryption: aes
#    # 导出数据加密密钥，支持 classpath:<path> 或 file:<path> 形式加载外部资源
#    encryption-key: '<AES 密钥字符串>'
#    # 导入数据解密密钥表，支持 classpath:<path> 或 file:<path> 形式加载外部资源
#    decryption-keys:
#      aes: '<AES 密钥字符串>'
#
############################## base配置 结束  ##############################

############################## 可视化设计器配置 开始  ##############################
#hussar-formdesign:
#  workspace: D:\hussar_8.2.1\hussar-front-platform               # 当前项目的工作空间，前端工程（hussar-front）与后端工程（hussar-web）需在一个工作空间下，工作空间一般为后端工程（hussar-web）的父级目录
#  offline-lr: true                                               # 本地利刃调试
#  format: true                                                # 是否开启格式化
#  sync-menu: true                                             # 是否配置菜单
#  multi-source: false                                         # 是否开启多数据源
#  project-path: c:/speed/code/project                         # 工程文件路径
#  project-root-path: /.project-store                             # 工程文件区分根目录
#  page-suffix: .vue                                           # 前台页面生成后缀
#  common-style-path: /src/assets/css                          # 公共样式文件生成路径
#  default-style-file-name: /default_value.css                 # 样式默认值文件名
#  project-custom-components-path: /customComponents           # 工程文件（自定义组件文件存放地址）
#  project-cover-path: /cover                                  # 工程文件（自定义组件/模板文件封面存放地址）
#  project-page-template-path: /PageTemplate                   # 工程文件（自定义模板文件存放地址）
#  datasource-store-path: /datasource/db.json                  # 数据源文件存放地址
#  datasource-type-store-path: /datasource/dataSourceType.json # 数据库类型配置文件存放地址
#  static-path: /static/speedcode                              # 静态资源路径
#  workflow-listener-path: /bpm/listener                       # 工作流监听器路径
#  workflow-path: /bpm/workflow                                # 工作流代码路径
#  style-scheme-space: /style-scheme                           # 样式方案space
#  web-url: http://localhost:8081                              # web预览地址
#  front-compile-path: c:/tmp/hussar-compile                   # 前端编译输出路径
#  front-compile-html-path: /src/pages/index/index.html        # 前端编译入口html文件相对路径
#  front-compile-server: http://localhost:8989/buildEntry      # 前端编译服务器地址
#  local-un-reset: false                                       # 是否开启本地不重启调试,默认不开启
#  restart: false                                              # devtools重启开关
#  developer-mode: false                                       # 是否开发者模式
#  lock-enabled: true                                          # 锁定启用
#  java-code-path: /src/main/java                              # java文件生成路径(相对路径)
#  css-code-path: /src/assets/css                              # css文件生成路径(相对路径)
#  back-project-path: hussar-web                                  # 天斧后端的项目路径
#  front-project-path: hussar-front                               # 天斧web端的项目路径
#  project-code-path: /code                                    # 天斧code代码仓库的路径
#  java-path: /com/jxdinfo/hussar                              # 天斧代码包路径前缀
#  vue-code-path: /src/pages/index                                # 文件生成地址
#  front-api-path: /src/pages/index                           # 前台生成api路径
#  mobile-front-project-path: hussar-mobile                    #移动端前端项目名称
#  mobile-url: localhost:8380                                  #移动端预览地址
#  mobile-front-api-path: /src/api                                # 移动端前台生成api路径
#  hussar-mobile-uni:                                             # 移动端uni前台的项目路径
#   uni-front-project-path:
#  menu-role: 超级管理员                                            # vue菜单生成后相关资源绑定的角色，多角色用逗号分隔
#  menu-role-group:                                               # vue菜单生成后相关资源绑定角色组下的角色，可选：系统角色、普通角色、管理角色
#  mobile-compile-server: http://localhost:8988/buildEntry       # 手机端编译服务地址                                                         # vue菜单生成后相关资源绑定角色组下的角色，可选：系统角色、普通角色、管理角色
#  mobile-compile-html-path: /public/index.html                  # 移动端编译入口html文件相对路径
#  mobile-compile-path: c:/tmp/hussar-compile                    # 移动前台编译输出路径
#  code-format-address: http://localhost:8820/codeFormat         # 前端生成代码格式化服务地址，修改后须注意与hussar-front中package.json的code-format端口号配置保持一致
#  checkedCode: false                                            # 发布时是否开启格式化校验，默认不开启
#  localCodeFormatter: false                                    # 发布时是否格式化上次发布合本地代码，默认不开启

############################## 可视化设计器配置 结束  ##############################

############################## 工作流配置 开始  ##############################
#  bpm:
#    modify-configuration-online: true       #是支持在线配置模式，在线配置模式参与者抄送人表单权限配置存储到表中
#    workflow-editable-online: true          #获取流程能否在线编辑（false只可以配置参与者，抄送人，表单权限，true流程画布所有的都可编辑）
#    form-editable-online: true              #获取表单能否在线编辑（true可编辑，false不可编辑）
#    use-security-level: false               #是否使用密级
#    order-by-time: false                    #办理历史的排序规则，先按照接受时间升序，再按照办理时间升序
#    use-datapush: false                     # 是否启用统一待办自动推送
#    system-id: 524168298611613696           # 统一待办应用编码
# 工作流接入消息中心配置
#    msg:
#      app-id: workflow #统一消息应用id
#      app-secret: 426bd4e7571f0bc777bbc48545582313 #统一消息应用密钥
#      todo-scene-code: todo #统一消息待办场景编码
#      reject-scene-code: reject #统一消息驳回场景编码
#      reminders-scene-code: reminders #统一消息催办场景编码
#      entrust-scene-code: entrust #统一消息委托场景编码
#      complete-scene-code: complete #统一消息流程完成编码
#      terminated-scene-code: terminated #统一消息流程终止编码
# 统一待办
#unified-todo-datapush:
#  use-datapush: true # 是否启用统一待办自动推送
#  system-id: 524168298611613696  # 统一待办应用编码

############################## 工作流推送数据 开始  ##############################
#bpm:
#    send-message: true  #是否推送数据到工作流  默认为false
#    tenant-id: e716ae159569361f7f7928ec21350cbc #租户ID
#    tenant-cipher: f65777f3efcae5b892b8f74870868908 #租户密钥
#    queue: hussar.bpm.sends #工作流MQ队列名称
#    exchange: hussar.bpm.sends #工作流MQ交换机
#    route-key: hussar.bpm.sends #工作流MQ路由键
############################## 工作流推送数据 结束  ##############################
############################## 工作流配置 结束  ##############################

############################## 消息中心配置 开始  ##############################
#    message:
#      queuePrefix:   #消息队列前缀
#      enable-message-service: false #开启消息服务
#      job-app-id: 543099687121723392 #定时任务appId  单体模式下使用hussar.job.execution.
############################## 消息中心配置 结束  ##############################

############################## 解析引擎配置 开始  ##############################
#knife4j:
#  enable: true
############################## 解析引擎配置 结束  ##############################

# 插件的配置
#plugin:
#  runMode: prod       # 插件运行模式. dev: 开发环境, prod: 生产环境,dev模式下运行的是代码，prod模式下运行的是jar包
#  enable: true        # 是否启用插件
#  pluginPath: E:\hussar-base-platform\pluginJar       # 插件存放的目录 插件的路径, 开发环境下配置为插件模块上级目录; 生产环境下配置到插件jar包存放目录。建议配置绝对路径
#  pluginConfigFilePath: ./hussar-configs          # 生产环境下, 插件文件的路径. 只在生产环境下生效
#  pluginRestPathPrefix: /                         # 统一配置访问插件rest接口前缀. 默认: /plugins,/代表不配置
#  enablePluginIdRestPathPrefix: false     # 是否启用插件id作为rest接口前缀, 默认为启用. 如果为启用, 则地址为 /pluginRestPathPrefix/pluginId,其中pluginRestPathPrefix: 为pluginRestPathPrefix的配置值, pluginId: 为插件id
#  enableSwaggerRefresh: true            # 是否启用Swagger刷新机制. 默认启用
#  backUpPath: backupPlugin              # 在卸载插件后, 备份插件的目录
#  uploadTempPath: temp                  # 上传的插件所存储的临时目录
#  version: 0.0.0                        # 当前主程序的版本号, 用于校验插件是否可安装. 插件中可通过插件配置信息 requires 来指定可安装的主程序版本。如果为: 0.0.0 的话, 表示不校验
#  exactVersionAllowed: false            # 设置为true表示插件设置的requires的版本号完全匹配version版本号才可允许插件安装, 即: requires=x.y.z; 设置为false表示插件设置的requires的版本号小于等于version值, 插件就可安装, 即requires<=x.y.z。默认为false
#  enablePluginIds                       # 启用的插件id
#  disablePluginIds:                     # 禁用的插件id, 禁用后系统不会启动该插件, 为Set集合,如果禁用所有插件, 则Set集合中返回一个字符: *
#    - disable-id1
#    - disable-id2
#  sortInitPluginIds:                    # 设置初始化时插件启动的顺序
#    - id1
#    - id2
#  enableWebSocket: false                # 是否启用webSocket的功能. 默认禁用

############################## 远程服务配置 开始  ##############################
#hussar-remote-server:
#  base:
#    name: hussar-web                            # base模块feign接口服务名，默认为hussar-web
#    url: http://localhost:8280                  # base模块feign接口服务url地址，默认为空
############################## 远程服务配置 开始  ##############################

##############################################################################
############################## hussar配置 结束  ##############################
##############################################################################


##############################################################################
############################## spring配置 开始  ##############################
##############################################################################
#spring:
#  jmx:
#    enabled: false
#  profiles:
#    active: dev
#  servlet:
#    multipart:
#      max-request-size: 100MB               # 最大请求大小
#      max-file-size: 100MB                  # 最大文件大小
#  aop:
#    proxy-target-class: true                #false为启用jdk默认动态代理,true为cglib动态代理
#  activiti:
#    check-process-definitions: false
#    database-schema-update: true
#    async-executor-activate: false
#  http:
#    encoding:
#      charset: utf-8
#      force: true
#      enabled: true

############# 消息中心 mongo配置 #################
#  data:
#     mongodb:
#       host: localhost # mongodb的连接地址
#       port: 27017 # mongodb的连接端口号
#       database: msg # mongodb的连接的数据库
#       username:
#       password:

############# 消息中心 rabbitmq配置 #################
#  rabbitmq:
#    addresses: localhost
#    port: 5672
#    username:
#    password:
#    virtual-host: /
#    publisher-confirms: true
#    publisher-returns: true

############# redis配置 #################
#  cache:
#    type: redis
#  redis:
#    host: localhost       #redis服务器地址
#    port: 6379            #redis服务器端口
#    password:   #redis 密码
#    database: 1           #默认连接的库
#    timeout: 2000         #连接超时时间（毫秒）
#    lettuce:
#      shutdown-timeout: 100 # 关闭超时时间
#      pool:
#        max-active: 3000        # 连接池最大连接数（使用负值表示没有限制）
#        max-idle: 3000          # 连接池中的最大空闲连接
#        min-idle: 0             # 连接池中的最小空闲连接
#        max-wait: -1            # 连接池最大阻塞等待时间（使用负值表示没有限制）
#        time-between-eviction-runs: 60000  #空闲链接检测线程检测周期。如果为负值，表示不运行检测线程。（单位：毫秒，默认为-layer）
#    cluster:
#      max-redirects: 3          #跨集群执行命令时要遵循的最大重定向数量
#      nodes:                    # cluster模式集群节点配置，或者host中配置，以英文逗号隔开127.0.0.1:6381,127.0.0.1:6382,......
#      - 127.0.0.1:6380
#      - 127.0.0.1:6381
#      - 127.0.0.1:6382
#      - 127.0.0.1:6383
#      - 127.0.0.1:6384
#      - 127.0.0.1:6385
#    sentinel:             # 哨兵模式配置
#      master: hussarmaster        #哨兵节点名称 Name of Redis server
#      nodes: 192.168.83.17:26379,192.168.83.17:26380,192.168.83.17:26381   #英文逗号（,）分割开的哨兵节点信息  Comma-separated list of host:port pairs.

#####################  动态数据源配置 MySQL ###################
#####################  MySQL数据库配置  ###################
#  datasource:
#    dynamic:
#      primary: master
#      strict: true
#      druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#        # 连接池的配置信息
#        # 连接池初始化时初始化的数据库连接数
#        # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#        # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#        initial-size: 1
#        # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#        # 如果空闲的连接数大于该值，则关闭多余的连接，
#        # 反之则创建更多的连接以满足最小连接数要求。
#        # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#        # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#        # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#        # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#        # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#        # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#        # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#        min-idle: 2
#        # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#        # 1. activeCount：正在使用的连接；
#        # 2. poolingCount：连接池中的空闲连接；
#        # 3. createTaskCount：正在生成的连接；
#        #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#        # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#        maxActive: 30
#        # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#        # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#        # 如果超时，Druid会抛出以下异常
#        # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#        # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#        maxWait: 30000
#        # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#        # removeAbandonedTimeoutMillis: 1800000
#        # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#        # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#        removeAbandoned: false
#        # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#        logAbandoned: true
#        # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#        # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#        # 回收连接池泄露的连接
#        #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#        # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#        # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#        # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#        # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#        timeBetweenEvictionRunsMillis: 30000
#        # 连接池是怎么判断一条连接是Idle状态的？
#        # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#        #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#        #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#        # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#        #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#        #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#        #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#        #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#        # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#        # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#        #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#        # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#        maxEvictableIdleTimeMillis: 180000
#        minEvictableIdleTimeMillis: 60000
#        phyTimeoutMillis: 3600000
#        #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#        # 连接池是如何判断连接是否有效?
#        # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#        # 如果是其他数据库，则使用validationQuery
#        # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#        # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#        # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#        testOnBorrow: false
#        # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#        # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#        testOnReturn: false
#        # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#        # testWhileIdle什么时候会起作用
#        #  获取连接时；
#        #  testOnBorrow==false;
#        #  testWhileIdle==true;
#        # 使用代码在DruidDataSource的getConnectionDirect方法
#        #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#        # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#        # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#        # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#        # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#        testWhileIdle: true
#        # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#        # Mysql:SELECT 1;
#        # SQLSERVER:SELECT 1;
#        # ORACLE:SELECT 'x' FROM DUAL;
#        # PostGresql:SELECT 'x';
#        # KingBase:SELECT 1;
#        # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#        #如果有相关数据库的ValidConnectionChecker，
#        # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#        # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#        #
#        #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#        # 不同数据库的默认值不同；
#        # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#        validationQuery: SELECT 1
#        # keepAlive：保持连接的有效性，也就是跟数据库续租；
#        # keepAlive什么时候会起作用?
#        # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#        # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#        # keepAlive是Druid用来保持连接有效性的；
#        # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#        keepAlive: true
#        # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#        filters: stat,slf4j
#        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#        connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#      datasource:
#        master:
#          url: jdbc:mysql://localhost:3306/hussar?autoReconnect=true&useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=false&useTimezone=true&serverTimezone=GMT%2B8&allowMultiQueries=true
#          username: root
#          password: 123456
#          db-name: hussar
#          driver-class-name: com.mysql.cj.jdbc.Driver
#          jdbc-from-ds: true
#          select-datasource-sql: SELECT CONN_NAME poolName,DRIVER_CLASS driverClassName,JDBC_URL url,USER_NAME userName,PASSWORD password  FROM `SYS_DATASOURCE` WHERE CONN_NAME != 'master'
#          druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#            # 连接池的配置信息
#            # 连接池初始化时初始化的数据库连接数
#            # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#            # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#            initial-size: 1
#            # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#            # 如果空闲的连接数大于该值，则关闭多余的连接，
#            # 反之则创建更多的连接以满足最小连接数要求。
#            # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#            # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#            # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#            # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#            # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#            # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#            # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#            min-idle: 2
#            # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#            # 1. activeCount：正在使用的连接；
#            # 2. poolingCount：连接池中的空闲连接；
#            # 3. createTaskCount：正在生成的连接；
#            #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#            # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#            maxActive: 30
#            # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#            # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#            # 如果超时，Druid会抛出以下异常
#            # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#            # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#            maxWait: 30000
#            # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#            # removeAbandonedTimeoutMillis: 1800000
#            # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#            # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#            removeAbandoned: false
#            # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#            logAbandoned: true
#            # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#            # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#            # 回收连接池泄露的连接
#            #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#            # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#            # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#            # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#            # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#            timeBetweenEvictionRunsMillis: 30000
#            # 连接池是怎么判断一条连接是Idle状态的？
#            # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#            #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#            #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#            # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#            #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#            #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#            #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#            #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#            # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#            # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#            #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#            # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#            maxEvictableIdleTimeMillis: 180000
#            minEvictableIdleTimeMillis: 60000
#            phyTimeoutMillis: 3600000
#            #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#            # 连接池是如何判断连接是否有效?
#            # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#            # 如果是其他数据库，则使用validationQuery
#            # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#            # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#            # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#            testOnBorrow: false
#            # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#            # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#            testOnReturn: false
#            # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#            # testWhileIdle什么时候会起作用
#            #  获取连接时；
#            #  testOnBorrow==false;
#            #  testWhileIdle==true;
#            # 使用代码在DruidDataSource的getConnectionDirect方法
#            #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#            # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#            # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#            # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#            # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#            testWhileIdle: true
#            # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#            # Mysql:SELECT 1;
#            # SQLSERVER:SELECT 1;
#            # ORACLE:SELECT 'x' FROM DUAL;
#            # PostGresql:SELECT 'x';
#            # KingBase:SELECT 1;
#            # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#            #如果有相关数据库的ValidConnectionChecker，
#            # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#            # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#            #
#            #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#            # 不同数据库的默认值不同；
#            # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#            validationQuery: SELECT 1
#            # keepAlive：保持连接的有效性，也就是跟数据库续租；
#            # keepAlive什么时候会起作用?
#            # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#            # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#            # keepAlive是Druid用来保持连接有效性的；
#            # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#            keepAlive: true
#            # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
#            filters: stat,slf4j
#            # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#            connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
###################  ORACLE数据库配置  ###################
#  datasource:
#    dynamic:
#      primary: master       #设置默认的数据源或者数据源组,默认值即为master
#      strict: true         #设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.
#      druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#        # 连接池的配置信息
#        # 连接池初始化时初始化的数据库连接数
#        # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#        # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#        initial-size: 1
#        # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#        # 如果空闲的连接数大于该值，则关闭多余的连接，
#        # 反之则创建更多的连接以满足最小连接数要求。
#        # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#        # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#        # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#        # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#        # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#        # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#        # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#        min-idle: 2
#        # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#        # 1. activeCount：正在使用的连接；
#        # 2. poolingCount：连接池中的空闲连接；
#        # 3. createTaskCount：正在生成的连接；
#        #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#        # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#        maxActive: 30
#        # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#        # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#        # 如果超时，Druid会抛出以下异常
#        # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#        # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#        maxWait: 30000
#        # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#        # removeAbandonedTimeoutMillis: 1800000
#        # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#        # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#        removeAbandoned: false
#        # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#        logAbandoned: true
#        # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#        # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#        # 回收连接池泄露的连接
#        #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#        # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#        # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#        # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#        # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#        timeBetweenEvictionRunsMillis: 30000
#        # 连接池是怎么判断一条连接是Idle状态的？
#        # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#        #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#        #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#        # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#        #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#        #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#        #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#        #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#        # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#        # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#        #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#        # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#        maxEvictableIdleTimeMillis: 180000
#        minEvictableIdleTimeMillis: 60000
#        phyTimeoutMillis: 3600000
#        #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#        # 连接池是如何判断连接是否有效?
#        # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#        # 如果是其他数据库，则使用validationQuery
#        # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#        # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#        # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#        testOnBorrow: false
#        # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#        # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#        testOnReturn: false
#        # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#        # testWhileIdle什么时候会起作用
#        #  获取连接时；
#        #  testOnBorrow==false;
#        #  testWhileIdle==true;
#        # 使用代码在DruidDataSource的getConnectionDirect方法
#        #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#        # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#        # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#        # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#        # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#        testWhileIdle: true
#        # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#        # Mysql:SELECT 1;
#        # SQLSERVER:SELECT 1;
#        # ORACLE:SELECT 'x' FROM DUAL;
#        # PostGresql:SELECT 'x';
#        # KingBase:SELECT 1;
#        # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#        #如果有相关数据库的ValidConnectionChecker，
#        # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#        # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#        #
#        #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#        # 不同数据库的默认值不同；
#        # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#        validationQuery: SELECT 1 FROM DUAL
#        # keepAlive：保持连接的有效性，也就是跟数据库续租；
#        # keepAlive什么时候会起作用?
#        # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#        # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#        # keepAlive是Druid用来保持连接有效性的；
#        # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#        keepAlive: true
#        # 打开PSCache，并且指定每个连接上PSCache的大小 在mysql下建议关闭。默认是false
#        poolPreparedStatements: true
#        maxPoolPreparedStatementPerConnectionSize: 20
#        # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#        filters: stat,slf4j
#        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#        connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#      datasource:
#        master:
#          url: jdbc:oracle:thin:@localhost:1521:orcl
#          username: HUSSAR
#          password: HUSSAR
#          db-name: HUSSAR
#          domain: localhost
#          driverClassName: oracle.jdbc.OracleDriver
#          jdbc-from-ds: true
#          select-datasource-sql: SELECT "CONN_NAME" poolName,"DRIVER_CLASS" driverClassName,"JDBC_URL" url,"USER_NAME" userName,"PASSWORD" password  FROM "SYS_DATASOURCE" WHERE "CONN_NAME" != 'master'
#          druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#            # 连接池的配置信息
#            # 连接池初始化时初始化的数据库连接数
#            # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#            # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#            initial-size: 1
#            # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#            # 如果空闲的连接数大于该值，则关闭多余的连接，
#            # 反之则创建更多的连接以满足最小连接数要求。
#            # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#            # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#            # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#            # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#            # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#            # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#            # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#            min-idle: 2
#            # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#            # 1. activeCount：正在使用的连接；
#            # 2. poolingCount：连接池中的空闲连接；
#            # 3. createTaskCount：正在生成的连接；
#            #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#            # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#            maxActive: 30
#            # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#            # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#            # 如果超时，Druid会抛出以下异常
#            # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#            # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#            maxWait: 30000
#            # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#            # removeAbandonedTimeoutMillis: 1800000
#            # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#            # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#            removeAbandoned: false
#            # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#            logAbandoned: true
#            # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#            # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#            # 回收连接池泄露的连接
#            #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#            # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#            # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#            # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#            # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#            timeBetweenEvictionRunsMillis: 30000
#            # 连接池是怎么判断一条连接是Idle状态的？
#            # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#            #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#            #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#            # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#            #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#            #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#            #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#            #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#            # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#            # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#            #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#            # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#            maxEvictableIdleTimeMillis: 180000
#            minEvictableIdleTimeMillis: 60000
#            phyTimeoutMillis: 3600000
#            #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#            # 连接池是如何判断连接是否有效?
#            # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#            # 如果是其他数据库，则使用validationQuery
#            # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#            # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#            # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#            testOnBorrow: false
#            # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#            # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#            testOnReturn: false
#            # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#            # testWhileIdle什么时候会起作用
#            #  获取连接时；
#            #  testOnBorrow==false;
#            #  testWhileIdle==true;
#            # 使用代码在DruidDataSource的getConnectionDirect方法
#            #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#            # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#            # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#            # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#            # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#            testWhileIdle: true
#            # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#            # Mysql:SELECT 1;
#            # SQLSERVER:SELECT 1;
#            # ORACLE:SELECT 'x' FROM DUAL;
#            # PostGresql:SELECT 'x';
#            # KingBase:SELECT 1;
#            # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#            #如果有相关数据库的ValidConnectionChecker，
#            # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#            # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#            #
#            #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#            # 不同数据库的默认值不同；
#            # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#            validationQuery: SELECT 1 FROM DUAL
#            # keepAlive：保持连接的有效性，也就是跟数据库续租；
#            # keepAlive什么时候会起作用?
#            # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#            # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#            # keepAlive是Druid用来保持连接有效性的；
#            # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#            keepAlive: true
#            # 打开PSCache，并且指定每个连接上PSCache的大小 在mysql下建议关闭。默认是false
#            poolPreparedStatements: true
#            maxPoolPreparedStatementPerConnectionSize: 20
#            # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#            filters: stat,slf4j
#            # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#            connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#mybatis-plus:
#  configuration:
#    jdbc-type-for-null: 'null'                             #Oracle数据库开启，否则使用updateAllColumnById()这种方法，如果列值为空，就会报错
#####################  动态数据源配置 PG ###################
#####################  PG数据库配置  ###################
#  datasource:
#    dynamic:
#      primary: master
#      strict: true
#      druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#        # 连接池的配置信息
#        # 连接池初始化时初始化的数据库连接数
#        # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#        # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#        initial-size: 1
#        # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#        # 如果空闲的连接数大于该值，则关闭多余的连接，
#        # 反之则创建更多的连接以满足最小连接数要求。
#        # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#        # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#        # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#        # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#        # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#        # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#        # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#        min-idle: 2
#        # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#        # 1. activeCount：正在使用的连接；
#        # 2. poolingCount：连接池中的空闲连接；
#        # 3. createTaskCount：正在生成的连接；
#        #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#        # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#        maxActive: 30
#        # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#        # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#        # 如果超时，Druid会抛出以下异常
#        # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#        # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#        maxWait: 30000
#        # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#        # removeAbandonedTimeoutMillis: 1800000
#        # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#        # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#        removeAbandoned: false
#        # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#        logAbandoned: true
#        # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#        # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#        # 回收连接池泄露的连接
#        #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#        # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#        # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#        # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#        # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#        timeBetweenEvictionRunsMillis: 30000
#        # 连接池是怎么判断一条连接是Idle状态的？
#        # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#        #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#        #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#        # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#        #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#        #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#        #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#        #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#        # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#        # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#        #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#        # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#        maxEvictableIdleTimeMillis: 180000
#        minEvictableIdleTimeMillis: 60000
#        phyTimeoutMillis: 3600000
#        #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#        # 连接池是如何判断连接是否有效?
#        # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#        # 如果是其他数据库，则使用validationQuery
#        # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#        # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#        # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#        testOnBorrow: false
#        # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#        # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#        testOnReturn: false
#        # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#        # testWhileIdle什么时候会起作用
#        #  获取连接时；
#        #  testOnBorrow==false;
#        #  testWhileIdle==true;
#        # 使用代码在DruidDataSource的getConnectionDirect方法
#        #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#        # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#        # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#        # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#        # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#        testWhileIdle: true
#        # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#        # Mysql:SELECT 1;
#        # SQLSERVER:SELECT 1;
#        # ORACLE:SELECT 'x' FROM DUAL;
#        # PostGresql:SELECT 'x';
#        # KingBase:SELECT 1;
#        # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#        #如果有相关数据库的ValidConnectionChecker，
#        # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#        # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#        #
#        #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#        # 不同数据库的默认值不同；
#        # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#        validationQuery: SELECT 1
#        # keepAlive：保持连接的有效性，也就是跟数据库续租；
#        # keepAlive什么时候会起作用?
#        # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#        # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#        # keepAlive是Druid用来保持连接有效性的；
#        # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#        keepAlive: true
#        # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#        filters: stat,slf4j
#        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#        connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#      datasource:
#        master:
#          url: jdbc:postgresql://localhost:5432/hussar?reWriteBatchedInserts=true
#          username: postgres
#          password: root
#          db-name: hussar
#          driver-class-name: org.postgresql.Driver
#          jdbc-from-ds: true
#          select-datasource-sql: SELECT CONN_NAME poolName,DRIVER_CLASS driverClassName,JDBC_URL url,USER_NAME userName,PASSWORD "password"  FROM SYS_DATASOURCE WHERE CONN_NAME != 'master'
#          druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#            # 连接池的配置信息
#            # 连接池初始化时初始化的数据库连接数
#            # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#            # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#            initial-size: 1
#            # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#            # 如果空闲的连接数大于该值，则关闭多余的连接，
#            # 反之则创建更多的连接以满足最小连接数要求。
#            # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#            # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#            # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#            # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#            # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#            # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#            # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#            min-idle: 2
#            # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#            # 1. activeCount：正在使用的连接；
#            # 2. poolingCount：连接池中的空闲连接；
#            # 3. createTaskCount：正在生成的连接；
#            #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#            # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#            maxActive: 30
#            # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#            # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#            # 如果超时，Druid会抛出以下异常
#            # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#            # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#            maxWait: 30000
#            # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#            # removeAbandonedTimeoutMillis: 1800000
#            # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#            # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#            removeAbandoned: false
#            # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#            logAbandoned: true
#            # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#            # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#            # 回收连接池泄露的连接
#            #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#            # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#            # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#            # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#            # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#            timeBetweenEvictionRunsMillis: 30000
#            # 连接池是怎么判断一条连接是Idle状态的？
#            # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#            #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#            #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#            # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#            #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#            #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#            #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#            #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#            # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#            # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#            #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#            # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#            maxEvictableIdleTimeMillis: 180000
#            minEvictableIdleTimeMillis: 60000
#            phyTimeoutMillis: 3600000
#            #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#            # 连接池是如何判断连接是否有效?
#            # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#            # 如果是其他数据库，则使用validationQuery
#            # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#            # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#            # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#            testOnBorrow: false
#            # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#            # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#            testOnReturn: false
#            # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#            # testWhileIdle什么时候会起作用
#            #  获取连接时；
#            #  testOnBorrow==false;
#            #  testWhileIdle==true;
#            # 使用代码在DruidDataSource的getConnectionDirect方法
#            #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#            # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#            # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#            # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#            # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#            testWhileIdle: true
#            # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#            # Mysql:SELECT 1;
#            # SQLSERVER:SELECT 1;
#            # ORACLE:SELECT 'x' FROM DUAL;
#            # PostGresql:SELECT 'x';
#            # KingBase:SELECT 1;
#            # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#            #如果有相关数据库的ValidConnectionChecker，
#            # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#            # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#            #
#            #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#            # 不同数据库的默认值不同；
#            # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#            validationQuery: SELECT 1
#            # keepAlive：保持连接的有效性，也就是跟数据库续租；
#            # keepAlive什么时候会起作用?
#            # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#            # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#            # keepAlive是Druid用来保持连接有效性的；
#            # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#            keepAlive: true
#            # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
#            filters: stat,slf4j
#            # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#            connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#################  DM数据库配置  ###################
#  jpa.properties.hibernate.dialect: org.hibernate.dialect.Oracle12cDialect
#  datasource:
#    dynamic:
#      primary: master       #设置默认的数据源或者数据源组,默认值即为master
#      strict: true         #设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.
#      druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#        # 连接池的配置信息
#        # 连接池初始化时初始化的数据库连接数
#        # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#        # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#        initial-size: 1
#        # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#        # 如果空闲的连接数大于该值，则关闭多余的连接，
#        # 反之则创建更多的连接以满足最小连接数要求。
#        # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#        # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#        # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#        # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#        # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#        # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#        # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#        min-idle: 2
#        # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#        # 1. activeCount：正在使用的连接；
#        # 2. poolingCount：连接池中的空闲连接；
#        # 3. createTaskCount：正在生成的连接；
#        #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#        # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#        maxActive: 30
#        # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#        # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#        # 如果超时，Druid会抛出以下异常
#        # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#        # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#        maxWait: 30000
#        # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#        # removeAbandonedTimeoutMillis: 1800000
#        # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#        # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#        removeAbandoned: false
#        # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#        logAbandoned: true
#        # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#        # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#        # 回收连接池泄露的连接
#        #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#        # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#        # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#        # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#        # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#        timeBetweenEvictionRunsMillis: 30000
#        # 连接池是怎么判断一条连接是Idle状态的？
#        # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#        #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#        #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#        # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#        #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#        #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#        #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#        #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#        # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#        # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#        # 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#        # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#        maxEvictableIdleTimeMillis: 180000
#        minEvictableIdleTimeMillis: 60000
#        phyTimeoutMillis: 3600000
#        #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#        # 连接池是如何判断连接是否有效?
#        # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#        # 如果是其他数据库，则使用validationQuery
#        # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#        # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#        # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#        testOnBorrow: false
#        # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#        # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#        testOnReturn: false
#        # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#        # testWhileIdle什么时候会起作用
#        #  获取连接时；
#        #  testOnBorrow==false;
#        #  testWhileIdle==true;
#        # 使用代码在DruidDataSource的getConnectionDirect方法
#        #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#        # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#        # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#        # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#        # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#        testWhileIdle: true
#        # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#        # Mysql:SELECT 1;
#        # SQLSERVER:SELECT 1;
#        # ORACLE:SELECT 'x' FROM DUAL;
#        # PostGresql:SELECT 'x';
#        # KingBase:SELECT 1;
#        # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#        #如果有相关数据库的ValidConnectionChecker，
#        # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#        # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#        #
#        #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#        # 不同数据库的默认值不同；
#        # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#        validationQuery: SELECT 1 FROM DUAL
#        # keepAlive：保持连接的有效性，也就是跟数据库续租；
#        # keepAlive什么时候会起作用?
#        # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#        # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#        # keepAlive是Druid用来保持连接有效性的；
#        # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#        keepAlive: true
#        # 打开PSCache，并且指定每个连接上PSCache的大小 在mysql下建议关闭。默认是false
#        poolPreparedStatements: true
#        maxPoolPreparedStatementPerConnectionSize: 20
#        # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#        filters: stat,slf4j
#        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#        connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#      datasource:
#        master:
#          url: jdbc:dm://localhost:5236
#          username: HUSSAR_V8
#          password: HUSSAR_V8
#          db-name: HUSSAR_V8     	 # 主数据源需要配置db-name
#          domain: localhost             # 多租户模式下绑定的域名
#          driver-class-name: dm.jdbc.driver.DmDriver
#          jdbc-from-ds: true
#          select-datasource-sql: SELECT "CONN_NAME" poolName,"DRIVER_CLASS" driverClassName,"JDBC_URL" url,"USER_NAME" userName,"PASSWORD" password  FROM "SYS_DATASOURCE" WHERE "CONN_NAME" != 'master'
#          druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#            # 连接池的配置信息
#            # 连接池初始化时初始化的数据库连接数
#            # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#            # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#            initial-size: 1
#            # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#            # 如果空闲的连接数大于该值，则关闭多余的连接，
#            # 反之则创建更多的连接以满足最小连接数要求。
#            # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#            # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#            # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#            # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#            # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#            # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#            # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#            min-idle: 2
#            # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#            # 1. activeCount：正在使用的连接；
#            # 2. poolingCount：连接池中的空闲连接；
#            # 3. createTaskCount：正在生成的连接；
#            #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#            # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#            maxActive: 30
#            # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#            # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#            # 如果超时，Druid会抛出以下异常
#            # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#            # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#            maxWait: 30000
#            # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#            # removeAbandonedTimeoutMillis: 1800000
#            # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#            # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#            removeAbandoned: false
#            # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#            logAbandoned: true
#            # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#            # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#            # 回收连接池泄露的连接
#            #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#            # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#            # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#            # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#            # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#            timeBetweenEvictionRunsMillis: 30000
#            # 连接池是怎么判断一条连接是Idle状态的？
#            # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#            #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#            #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#            # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#            #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#            #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#            #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#            #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#            # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#            # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#            #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#            # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#            maxEvictableIdleTimeMillis: 180000
#            minEvictableIdleTimeMillis: 60000
#            phyTimeoutMillis: 3600000
#            #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#            # 连接池是如何判断连接是否有效?
#            # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#            # 如果是其他数据库，则使用validationQuery
#            # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#            # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#            # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#            testOnBorrow: false
#            # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#            # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#            testOnReturn: false
#            # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#            # testWhileIdle什么时候会起作用
#            #  获取连接时；
#            #  testOnBorrow==false;
#            #  testWhileIdle==true;
#            # 使用代码在DruidDataSource的getConnectionDirect方法
#            #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#            # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#            # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#            # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#            # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#            testWhileIdle: true
#            # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#            # Mysql:SELECT 1;
#            # SQLSERVER:SELECT 1;
#            # ORACLE:SELECT 'x' FROM DUAL;
#            # PostGresql:SELECT 'x';
#            # KingBase:SELECT 1;
#            # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#            #如果有相关数据库的ValidConnectionChecker，
#            # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#            # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#            #
#            #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#            # 不同数据库的默认值不同；
#            # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#            validationQuery: SELECT 1 FROM DUAL
#            # keepAlive：保持连接的有效性，也就是跟数据库续租；
#            # keepAlive什么时候会起作用?
#            # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#            # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#            # keepAlive是Druid用来保持连接有效性的；
#            # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#            keepAlive: true
#            # 打开PSCache，并且指定每个连接上PSCache的大小 在mysql下建议关闭。默认是false
#            poolPreparedStatements: true
#            maxPoolPreparedStatementPerConnectionSize: 20
#            # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#            filters: stat,slf4j
#            # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#            connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
###################  sqlServer数据库配置  ###################
#  datasource:
#    dynamic:
#      primary: master       #设置默认的数据源或者数据源组,默认值即为master
#      strict: true         #设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.
#      druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#        # 连接池的配置信息
#        # 连接池初始化时初始化的数据库连接数
#        # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#        # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#        initial-size: 1
#        # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#        # 如果空闲的连接数大于该值，则关闭多余的连接，
#        # 反之则创建更多的连接以满足最小连接数要求。
#        # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#        # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#        # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#        # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#        # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#        # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#        # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#        min-idle: 1
#        # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#        # 1. activeCount：正在使用的连接；
#        # 2. poolingCount：连接池中的空闲连接；
#        # 3. createTaskCount：正在生成的连接；
#        #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#        # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#        maxActive: 30
#        # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#        # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#        # 如果超时，Druid会抛出以下异常
#        # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#        # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#        maxWait: 30000
#        # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#        # removeAbandonedTimeoutMillis: 1800000
#        # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#        # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#        removeAbandoned: false
#        # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#        logAbandoned: true
#        # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#        # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#        # 回收连接池泄露的连接
#        #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#        # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#        # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#        # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#        # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#        timeBetweenEvictionRunsMillis: 30000
#        # 连接池是怎么判断一条连接是Idle状态的？
#        # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#        #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#        #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#        # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#        #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#        #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#        #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#        #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#        # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#        # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#        # 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#        # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#        maxEvictableIdleTimeMillis: 180000
#        minEvictableIdleTimeMillis: 60000
#        phyTimeoutMillis: 3600000
#        #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#        # 连接池是如何判断连接是否有效?
#        # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#        # 如果是其他数据库，则使用validationQuery
#        # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#        # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#        # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#        testOnBorrow: false
#        # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#        # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#        testOnReturn: false
#        # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#        # testWhileIdle什么时候会起作用
#        #  获取连接时；
#        #  testOnBorrow==false;
#        #  testWhileIdle==true;
#        # 使用代码在DruidDataSource的getConnectionDirect方法
#        #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#        # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#        # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#        # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#        # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#        testWhileIdle: true
#        # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#        # Mysql:SELECT 1;
#        # SQLSERVER:SELECT 1;
#        # ORACLE:SELECT 'x' FROM DUAL;
#        # PostGresql:SELECT 'x';
#        # KingBase:SELECT 1;
#        # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#        #如果有相关数据库的ValidConnectionChecker，
#        # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#        # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#        #
#        #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#        # 不同数据库的默认值不同；
#        # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#        validationQuery: SELECT 1
#        # keepAlive：保持连接的有效性，也就是跟数据库续租；
#        # keepAlive什么时候会起作用?
#        # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#        # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#        # keepAlive是Druid用来保持连接有效性的；
#        # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#        keepAlive: true
#        # 打开PSCache，并且指定每个连接上PSCache的大小 在mysql下建议关闭。默认是false
#        poolPreparedStatements: true
#        maxPoolPreparedStatementPerConnectionSize: 20
#        # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#        filters: stat,slf4j
#        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#        connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#      datasource:
#        master:
#          url: jdbc:sqlserver://;serverName=192.168.2.138;databaseName=hussar8-group3;port=1433
#          username: group
#          password: 123456
#          db-name: hussar8
#          driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
#          jdbc-from-ds: true
#          select-datasource-sql: SELECT CONN_NAME poolName,DRIVER_CLASS driverClassName,JDBC_URL url,USER_NAME userName,PASSWORD password  FROM SYS_DATASOURCE WHERE CONN_NAME != 'master'
#          druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#            # 连接池的配置信息
#            # 连接池初始化时初始化的数据库连接数
#            # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#            # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#            initial-size: 1
#            # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#            # 如果空闲的连接数大于该值，则关闭多余的连接，
#            # 反之则创建更多的连接以满足最小连接数要求。
#            # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#            # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#            # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#            # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#            # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#            # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#            # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#            min-idle: 1
#            # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#            # 1. activeCount：正在使用的连接；
#            # 2. poolingCount：连接池中的空闲连接；
#            # 3. createTaskCount：正在生成的连接；
#            #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#            # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#            maxActive: 30
#            # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#            # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#            # 如果超时，Druid会抛出以下异常
#            # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#            # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#            maxWait: 30000
#            # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#            # removeAbandonedTimeoutMillis: 1800000
#            # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#            # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#            removeAbandoned: false
#            # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#            logAbandoned: true
#            # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#            # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#            # 回收连接池泄露的连接
#            #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#            # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#            # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#            # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#            # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#            timeBetweenEvictionRunsMillis: 30000
#            # 连接池是怎么判断一条连接是Idle状态的？
#            # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#            #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#            #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#            # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#            #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#            #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#            #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#            #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#            # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#            # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#            #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#            # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#            maxEvictableIdleTimeMillis: 180000
#            minEvictableIdleTimeMillis: 60000
#            phyTimeoutMillis: 3600000
#            #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#            # 连接池是如何判断连接是否有效?
#            # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#            # 如果是其他数据库，则使用validationQuery
#            # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#            # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#            # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#            testOnBorrow: false
#            # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#            # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#            testOnReturn: false
#            # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#            # testWhileIdle什么时候会起作用
#            #  获取连接时；
#            #  testOnBorrow==false;
#            #  testWhileIdle==true;
#            # 使用代码在DruidDataSource的getConnectionDirect方法
#            #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#            # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#            # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#            # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#            # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#            testWhileIdle: true
#            # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#            # Mysql:SELECT 1;
#            # SQLSERVER:SELECT 1;
#            # OSCAR:SELECT 1;
#            # ORACLE:SELECT 'x' FROM DUAL;
#            # PostGresql:SELECT 'x';
#            # KingBase:SELECT 1;
#            # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#            #如果有相关数据库的ValidConnectionChecker，
#            # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#            # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#            #
#            #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#            # 不同数据库的默认值不同；
#            # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#            validationQuery: SELECT 1
#            # keepAlive：保持连接的有效性，也就是跟数据库续租；
#            # keepAlive什么时候会起作用?
#            # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#            # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#            # keepAlive是Druid用来保持连接有效性的；
#            # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#            keepAlive: true
#            # 打开PSCache，并且指定每个连接上PSCache的大小 在mysql下建议关闭。默认是false
#            poolPreparedStatements: true
#            maxPoolPreparedStatementPerConnectionSize: 20
#            # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#            filters: stat,slf4j
#            # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#            connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
###################  oscar数据库配置  ###################
#  datasource:
#    dynamic:
#      primary: master       #设置默认的数据源或者数据源组,默认值即为master
#      strict: true         #设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.
#      druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#        # 连接池的配置信息
#        # 连接池初始化时初始化的数据库连接数
#        # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#        # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#        initial-size: 1
#        # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#        # 如果空闲的连接数大于该值，则关闭多余的连接，
#        # 反之则创建更多的连接以满足最小连接数要求。
#        # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#        # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#        # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#        # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#        # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#        # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#        # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#        min-idle: 1
#        # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#        # 1. activeCount：正在使用的连接；
#        # 2. poolingCount：连接池中的空闲连接；
#        # 3. createTaskCount：正在生成的连接；
#        #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#        # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#        maxActive: 30
#        # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#        # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#        # 如果超时，Druid会抛出以下异常
#        # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#        # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#        maxWait: 30000
#        # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#        # removeAbandonedTimeoutMillis: 1800000
#        # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#        # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#        removeAbandoned: false
#        # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#        logAbandoned: true
#        # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#        # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#        # 回收连接池泄露的连接
#        #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#        # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#        # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#        # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#        # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#        timeBetweenEvictionRunsMillis: 30000
#        # 连接池是怎么判断一条连接是Idle状态的？
#        # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#        #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#        #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#        # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#        #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#        #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#        #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#        #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#        # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#        # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#        # 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#        # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#        maxEvictableIdleTimeMillis: 180000
#        minEvictableIdleTimeMillis: 60000
#        phyTimeoutMillis: 3600000
#        #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#        # 连接池是如何判断连接是否有效?
#        # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#        # 如果是其他数据库，则使用validationQuery
#        # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#        # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#        # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#        testOnBorrow: false
#        # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#        # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#        testOnReturn: false
#        # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#        # testWhileIdle什么时候会起作用
#        #  获取连接时；
#        #  testOnBorrow==false;
#        #  testWhileIdle==true;
#        # 使用代码在DruidDataSource的getConnectionDirect方法
#        #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#        # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#        # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#        # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#        # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#        testWhileIdle: true
#        # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#        # Mysql:SELECT 1;
#        # SQLSERVER:SELECT 1;
#        # ORACLE:SELECT 'x' FROM DUAL;
#        # PostGresql:SELECT 'x';
#        # KingBase:SELECT 1;
#        # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#        #如果有相关数据库的ValidConnectionChecker，
#        # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#        # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#        #
#        #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#        # 不同数据库的默认值不同；
#        # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#        validationQuery: SELECT 1
#        # keepAlive：保持连接的有效性，也就是跟数据库续租；
#        # keepAlive什么时候会起作用?
#        # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#        # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#        # keepAlive是Druid用来保持连接有效性的；
#        # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#        keepAlive: true
#        # 打开PSCache，并且指定每个连接上PSCache的大小 在mysql下建议关闭。默认是false
#        poolPreparedStatements: true
#        maxPoolPreparedStatementPerConnectionSize: 20
#        # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#        filters: stat,slf4j
#        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#        connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#      datasource:
#        master:
#          url: jdbc:oscar://192.168.2.34:2003/osrdb
#          username: SYSDBA
#          password: szoscar55
#          db-name: SYSDBA
#          driver-class-name: com.oscar.Driver
#          jdbc-from-ds: true
#          select-datasource-sql: SELECT CONN_NAME poolName,DRIVER_CLASS driverClassName,JDBC_URL url,USER_NAME userName,PASSWORD password  FROM SYS_DATASOURCE WHERE CONN_NAME != 'master'
#          druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#            # 连接池的配置信息
#            # 连接池初始化时初始化的数据库连接数
#            # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#            # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#            initial-size: 1
#            # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#            # 如果空闲的连接数大于该值，则关闭多余的连接，
#            # 反之则创建更多的连接以满足最小连接数要求。
#            # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#            # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#            # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#            # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#            # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#            # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#            # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#            min-idle: 1
#            # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#            # 1. activeCount：正在使用的连接；
#            # 2. poolingCount：连接池中的空闲连接；
#            # 3. createTaskCount：正在生成的连接；
#            #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#            # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#            maxActive: 30
#            # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#            # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#            # 如果超时，Druid会抛出以下异常
#            # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#            # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#            maxWait: 30000
#            # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#            # removeAbandonedTimeoutMillis: 1800000
#            # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#            # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#            removeAbandoned: false
#            # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#            logAbandoned: true
#            # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#            # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#            # 回收连接池泄露的连接
#            #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#            # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#            # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#            # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#            # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#            timeBetweenEvictionRunsMillis: 30000
#            # 连接池是怎么判断一条连接是Idle状态的？
#            # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#            #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#            #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#            # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#            #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#            #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#            #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#            #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#            # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#            # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#            #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#            # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#            maxEvictableIdleTimeMillis: 180000
#            minEvictableIdleTimeMillis: 60000
#            phyTimeoutMillis: 3600000
#            #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#            # 连接池是如何判断连接是否有效?
#            # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#            # 如果是其他数据库，则使用validationQuery
#            # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#            # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#            # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#            testOnBorrow: false
#            # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#            # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#            testOnReturn: false
#            # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#            # testWhileIdle什么时候会起作用
#            #  获取连接时；
#            #  testOnBorrow==false;
#            #  testWhileIdle==true;
#            # 使用代码在DruidDataSource的getConnectionDirect方法
#            #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#            # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#            # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#            # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#            # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#            testWhileIdle: true
#            # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#            # Mysql:SELECT 1;
#            # SQLSERVER:SELECT 1;
#            # OSCAR:SELECT 1;
#            # ORACLE:SELECT 'x' FROM DUAL;
#            # PostGresql:SELECT 'x';
#            # KingBase:SELECT 1;
#            # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#            #如果有相关数据库的ValidConnectionChecker，
#            # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#            # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#            #
#            #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#            # 不同数据库的默认值不同；
#            # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#            validationQuery: SELECT 1
#            # keepAlive：保持连接的有效性，也就是跟数据库续租；
#            # keepAlive什么时候会起作用?
#            # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#            # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#            # keepAlive是Druid用来保持连接有效性的；
#            # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#            keepAlive: true
#            # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
#            filters: stat,slf4j
#            # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#            connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
################### KINGBASE数据库配置 ###################
#  datasource:
#    dynamic:
#      primary: master
#      strict: true
#      druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#        # 连接池的配置信息
#        # 连接池初始化时初始化的数据库连接数
#        # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#        # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#        initial-size: 1
#        # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#        # 如果空闲的连接数大于该值，则关闭多余的连接，
#        # 反之则创建更多的连接以满足最小连接数要求。
#        # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#        # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#        # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#        # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#        # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#        # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#        # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#        min-idle: 2
#        # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#        # 1. activeCount：正在使用的连接；
#        # 2. poolingCount：连接池中的空闲连接；
#        # 3. createTaskCount：正在生成的连接；
#        #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#        # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#        maxActive: 30
#        # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#        # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#        # 如果超时，Druid会抛出以下异常
#        # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#        # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#        maxWait: 30000
#        # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#        # removeAbandonedTimeoutMillis: 1800000
#        # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#        # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#        removeAbandoned: false
#        # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#        logAbandoned: true
#        # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#        # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#        # 回收连接池泄露的连接
#        #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#        # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#        # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#        # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#        # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#        timeBetweenEvictionRunsMillis: 30000
#        # 连接池是怎么判断一条连接是Idle状态的？
#        # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#        #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#        #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#        # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#        #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#        #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#        #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#        #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#        # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#        # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#        #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#        # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#        maxEvictableIdleTimeMillis: 180000
#        minEvictableIdleTimeMillis: 60000
#        phyTimeoutMillis: 3600000
#        #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#        # 连接池是如何判断连接是否有效?
#        # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#        # 如果是其他数据库，则使用validationQuery
#        # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#        # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#        # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#        testOnBorrow: false
#        # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#        # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#        testOnReturn: false
#        # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#        # testWhileIdle什么时候会起作用
#        #  获取连接时；
#        #  testOnBorrow==false;
#        #  testWhileIdle==true;
#        # 使用代码在DruidDataSource的getConnectionDirect方法
#        #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#        # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#        # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#        # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#        # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#        testWhileIdle: true
#        # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#        # Mysql:SELECT 1;
#        # SQLSERVER:SELECT 1;
#        # ORACLE:SELECT 'x' FROM DUAL;
#        # PostGresql:SELECT 'x';
#        # KingBase:SELECT 1;
#        # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#        #如果有相关数据库的ValidConnectionChecker，
#        # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#        # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#        #
#        #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#        # 不同数据库的默认值不同；
#        # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#        validationQuery: SELECT 1
#        # keepAlive：保持连接的有效性，也就是跟数据库续租；
#        # keepAlive什么时候会起作用?
#        # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#        # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#        # keepAlive是Druid用来保持连接有效性的；
#        # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#        keepAlive: true
#        # 配置监控统计拦截的filters，去掉后监控界面sql无法统计
#        filters: stat,slf4j
#        # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#        connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
#      datasource:
#        master:
#          url: jdbc:kingbase8://192.168.2.191:54321/hussar_base_dev
#          username: hussar_base_dev
#          password: 123456
#          db-name: hussar_base_dev
#          driver-class-name: com.kingbase8.Driver
#          jdbc-from-ds: true
#          select-datasource-sql: SELECT CONN_NAME poolName,DRIVER_CLASS driverClassName,JDBC_URL url,USER_NAME userName,PASSWORD "password"  FROM SYS_DATASOURCE WHERE CONN_NAME != 'master'
#          druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置)
#            # 连接池的配置信息
#            # 连接池初始化时初始化的数据库连接数
#            # 当项目第一次进行增，删，改，查的时候，连接池会初始化，会根据initialSize参数初始化数据库连接放入连接池中。
#            # initialSize的作用是告诉连接池初始化时应该初始化的物理连接数，要注意的是这个值越大，第一次调用数据库时越慢。
#            initial-size: 1
#            # 连接池中的最小空闲连接数，Druid会定时扫描连接池的连接，
#            # 如果空闲的连接数大于该值，则关闭多余的连接，
#            # 反之则创建更多的连接以满足最小连接数要求。
#            # 设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，
#            # 但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时
#
#            # 当连接池初始化时，会初始化一个定时清除空闲连接的任务DestroyTask，
#            # 该任务默认是1分钟执行一次（使用timeBetweenEvictionRunsMillis参数设置)
#            # 在这个定时任务中会判断连接池的连接是否满足关闭的条件，如果满足则关闭，满足的条件如下：
#            # 1. 空闲时间大于minEvictableIdleTimeMillis（默认30分钟），并且空闲连接数大于minIdle；
#            # 2. 空闲时间大于maxEvictableIdleTimeMillis（默认7小时）
#            min-idle: 2
#            # maxActive：连接池中的最大连接数，连接池中的连接包含3部分：
#            # 1. activeCount：正在使用的连接；
#            # 2. poolingCount：连接池中的空闲连接；
#            # 3. createTaskCount：正在生成的连接；
#            #这三部分的连接总和不能超过maxActive；数据库的连接总数是有限制的，有时候僧多粥少，只能限制每个应用的连接数了。
#            # maxActive在Druid中有多处使用，最主要的一处是在CreateConnectionTask中
#            maxActive: 30
#            # 从连接池中获取连接的最大等待时间，单位ms，默认-1，即会一直等待下去
#            # 使用Druid时都会设置这个参数，这样如果是获取连接超时，更容易从日志中获取调用失败的原因。
#            # 如果超时，Druid会抛出以下异常
#            # Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
#            # maxWait默认是不超时，即如果连接池没有空闲连接，则会一直等待下去，但是一般的接口都是有超时时间的，如果接口超时，不方便定位出来是获取不到连接导致的，最好设置maxWait，并且小于接口的超时时间
#            maxWait: 30000
#            # removeAbandonedTimeoutMillis  : 单个事务使用多数据源的功能，重写了Spring的ConnectionHolder，由于笔者的疏忽，每次从ConnectionHolder中获取连接时都获取到了两条连接，但是只是使用了其中的一条，相当于另一条连接只是从连接池中拿出来了，但是再也不会还回去了，这样就导致了连接池中的连接很快就消耗光了，即activeCount=maxActive。
#            # removeAbandonedTimeoutMillis: 1800000
#            # removeAbandoned  应该Druid会定期检查池中借出去的连接是否处于运行状态，如果不是处于运行状态，并且借出时间超过removeAbandonedTimeoutMillis（默认5分钟）就会回收该连接。
#            # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
#            removeAbandoned: false
#            # logAbandoned  //判断是否要记录连接回收日志，这个很重要，可以及时发现项目中是否有连接泄露
#            logAbandoned: true
#            # timeBetweenEvictionRunsMillis默认值是60s,主要作用在两处地方 作为DestroyTask执行的时间周期，DestroyTask主要有两个作用：
#            # 判断连接池的连接空闲数是否大于minIdle，如果是则关闭多余的连接，反之则新增连接，
#            # 回收连接池泄露的连接
#            #作为验证连接是否有效的时间周期，如果testOnBorrow==false并且testWhileIdle==true,
#            # 则在应用获取连接的时候会判断连接的空闲时间是否大于timeBetweenEvictionRunsMillis，如果大于则会验证该连接是否有效。
#            # timeBetweenEvictionRunsMillis可以用来控制空闲连接数的回收周期
#            # timeBetweenEvictionRunsMillis可以用来控制回收泄露连接的周期
#            # timeBetweenEvictionRunsMillis连接的空闲时间大于该值testWhileIdle才起作用
#            timeBetweenEvictionRunsMillis: 30000
#            # 连接池是怎么判断一条连接是Idle状态的？
#            # minEvictableIdleTimeMillis：最小空闲时间，默认30分钟，
#            #   如果连接池中非运行中的连接数大于minIdle，并且那部分连接的非运行时间大于minEvictableIdleTimeMillis，则连接池会将那部分连接设置成Idle状态并关闭；
#            #   也就是说如果一条连接30分钟都没有使用到，并且这种连接的数量超过了minIdle，则这些连接就会被关闭了。
#            # maxEvictableIdleTimeMillis：最大空闲时间，默认7小时，
#            #   如果minIdle设置得比较大，连接池中的空闲连接数一直没有超过minIdle，
#            #   这时那些空闲连接是不是一直不用关闭？当然不是，如果连接太久没用，数据库也会把它关闭，这时如果连接池不把这条连接关闭，
#            #   系统就会拿到一条已经被数据库关闭的连接。为了避免这种情况，Druid会判断池中的连接如果非运行时间大于maxEvictableIdleTimeMillis，
#            #   也会强行把它关闭，而不用判断空闲连接数是否小于minIdle；
#            # minEvictableIdleTimeMillis连接空闲时间大于该值并且池中空闲连接大于minIdle则关闭该连接
#            # maxEvictableIdleTimeMillis连接空闲时间大于该值，不管minIdle都关闭该连接
#            #// 设置连接最少存活时长和最大存活时长，超过上限才会被清理，
#            # 需要注意满足(maxEvictableIdleTimeMillis-minEvictableIdleTimeMillis>timeBetweenEvictionRunsMillis)的条件
#            maxEvictableIdleTimeMillis: 180000
#            minEvictableIdleTimeMillis: 60000
#            phyTimeoutMillis: 3600000
#            #如果为true（默认false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的。
#            # 连接池是如何判断连接是否有效?
#            # 如果是常用的数据库，则使用${DBNAME}ValidConnectionChecker进行判断，比如Mysql数据库，使用MySqlValidConnectionChecker的isValidConnection进行判断；
#            # 如果是其他数据库，则使用validationQuery
#            # 验证不通过则会直接关闭该连接，并重新从连接池获取下一条连接；
#            # testOnBorrow能够确保我们每次都能获取到可用的连接，但如果设置成true，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，
#            # 可以将testOnBorrow设成false，testWhileIdle设置成true这样能获得比较好的性能。
#            testOnBorrow: false
#            # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用。
#            # 当连接使用完，调用commit或者rollback方法后，连接池会回收该连接，该参数主要在DruidDataSource的recycle方法中用到
#            testOnReturn: false
#            # 如果为true（默认true），当应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用。
#            # testWhileIdle什么时候会起作用
#            #  获取连接时；
#            #  testOnBorrow==false;
#            #  testWhileIdle==true;
#            # 使用代码在DruidDataSource的getConnectionDirect方法
#            #注意：此时判断连接空闲的依据是空闲时间大于timeBetweenEvictionRunsMillis（默认1分钟），
#            # 并不是使用minEvictableIdleTimeMillis跟maxEvictableIdleTimeMillis，
#            # 也就是说如果连接空闲时间超过一分钟就测试一下连接的有效性，但并不是直接剔除；
#            # 而如果空闲时间超过了minEvictableIdleTimeMillis则会直接剔除。
#            # testWhileIdle的作用跟testOnBorrow是差不多的，都是在获取连接的时候测试连接的有效性，如果两者都为true，则testOnBorrow优先级高，则不会使用到testWhileIdle。
#            testWhileIdle: true
#            # validationQuery：Druid用来测试连接是否可用的SQL语句,默认值每种数据库都不相同：
#            # Mysql:SELECT 1;
#            # SQLSERVER:SELECT 1;
#            # ORACLE:SELECT 'x' FROM DUAL;
#            # PostGresql:SELECT 'x';
#            # KingBase:SELECT 1;
#            # 当Druid遇到testWhileIdle，testOnBorrow，testOnReturn时，就会验证连接的有效性，验证规则如下：
#            #如果有相关数据库的ValidConnectionChecker，
#            # 则使用ValidConnectionChecker验证（Druid提供常用数据库的ValidConnectionChecker，包括MSSQLValidConnectionChecker，
#            # MySqlValidConnectionChecker，OracleValidConnectionChecker，PGValidConnectionChecker）；
#            #
#            #如果没有ValidConnectionChecker，则直接使用validationQuery验证；
#            # 不同数据库的默认值不同；
#            # 如果是Mysql数据库，则validationQuery不会起作用，Mysql会使用ping的方式验证；
#            validationQuery: SELECT 1
#            # keepAlive：保持连接的有效性，也就是跟数据库续租；
#            # keepAlive什么时候会起作用?
#            # 当连接的空闲时间大于keepAliveBetweenTimeMillis（默认2分钟），但是小于minEvictableIdleTimeMillis（默认30分钟），Druid会通过调用validationQuery保持该连接的有效性。
#            # 当连接空闲时间大于minEvictableIdleTimeMillis，Druid会直接将该连接关闭，keepAlive会无效。
#            # keepAlive是Druid用来保持连接有效性的；
#            # 只有空闲时间大于keepAliveBetweenTimeMillis并且小于minEvictableIdleTimeMillis该参数才会有用
#            keepAlive: true
#            # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
#            filters: stat,slf4j
#            # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
#            connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
##############################################################################
############################## spring配置 结束  ##############################
##############################################################################


###################################################################################
############################## mybatis-plus配置 开始  ##############################
###################################################################################
#mybatis-plus:
#  type-handlers-package: com.jxdinfo.hussar.support.mp.typeconvter  # a,b, 转化 string[]
#  mapper-locations: classpath*:com/jxdinfo/hussar/**/mapping/*.xml        #添加自定义包路径，使用英文逗号,隔开
#  typeAliasesPackage: com.jxdinfo.hussar.**.model,com.xxxx.**.model       #添加自定义包路径，使用英文逗号,隔开
#  typeEnumsPackage: com.jxdinfo.hussar.common.constant.enums
#  check-config-location: true
#  global-config:
#    banner: false                     # 是否开启 LOGO
#    db-config:
#      id-type: assign-id            # 主键类型  auto: 数据库ID自增， none:该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)，input:用户输入ID(该类型可以通过自己注册自动填充插件进行填充)，assign-id: 分配ID (主键类型为number或string,雪花算法)，assign-uuid: 分配UUID (主键类型为 string,UUID.replace("-",""))
#        logic-delete-value: 1           # 逻辑删除全局值（默认 1、表示已删除）
#        logic-not-delete-value: 0       # 逻辑未删除全局值（默认 0、表示未删除）
#    enable-sql-runner: true           #是否初始化 SqlRunner， SqlRunner为SQL增强工具，用于在代码中使用原生SQL
#  configuration:
#    map-underscore-to-camel-case: true                      #默认为true
#    cache-enabled: true                                     # 配置的缓存的全局开关
#    lazyLoadingEnabled: true                                # 延时加载的开关
#    multipleResultSetsEnabled: true                         # 开启的话，延时加载一个属性时会加载该对象全部属性，否则按需加载属性
#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  # 打印sql语句,调试用
###################################################################################
############################## mybatis-plus配置 结束  ##############################
###################################################################################


##############################################################################
############################## 其它三方配置 开始  ##############################
##############################################################################

############################## 日志配置 开始  ##############################
#logging:
#  config: classpath:log4j2.xml          # 详细日志配置文件
#  level:
#    root: INFO                          # 日志默认输出级别
############################## 日志配置 结束  ##############################

##############################################################################
############################## 其它三方配置 结束  ##############################
##############################################################################
